{
  "files": [
    {
      "name": "main",
      "content": "import { render, Component } from \"solid-js/web\";\nimport { createStore } from \"solid-js/store\";\nimport { useForm, useDirectives } from \"./validation\";\nimport \"./styles.css\";\n\nconst EMAILS = [\"johnsmith@outlook.com\", \"mary@gmail.com\", \"djacobs@move.org\"];\n\nfunction fetchUserName(name: string) {\n  return new Promise((resolve) => {\n    setTimeout(() => resolve(EMAILS.indexOf(name) > -1), 200);\n  });\n}\n\nconst ErrorMessage: Component<{ error: string }> = ({ error }) => <span class=\"error-message\">{error}</span>;\n\nconst App = () => {\n  const { validate, formSubmit, errors } = useForm({\n    errorClass: \"error-input\"\n  });\n  const [fields, setFields] = createStore();\n  const fn = (form: HTMLFormElement) => {\n    form.submit()\n    console.log(\"Done\");\n  };\n  const userNameExists = async ({ value }: HTMLInputElement) => {\n    const exists = await fetchUserName(value);\n    return exists && `${value} is already being used`;\n  };\n  const matchesPassword = ({ value }: HTMLInputElement) =>\n    value === fields.password ? false : \"Passwords must Match\";\n\n  useDirectives(formSubmit, validate)\n  return (\n    <form use:formSubmit={fn}>\n      <h1>Sign Up</h1>\n      <div class=\"field-block\">\n        <input\n          name=\"email\"\n          type=\"email\"\n          placeholder=\"Email\"\n          required\n          use:validate={[userNameExists]}\n        />\n        {errors.email && <ErrorMessage error={errors.email} />}\n      </div>\n      <div class=\"field-block\">\n        <input\n          type=\"password\"\n          name=\"password\"\n          placeholder=\"Password\"\n          required=\"\"\n          minlength=\"8\"\n          onInput={(e) => setFields(\"password\", e.target.value)}\n          use:validate\n        />\n        {errors.password && <ErrorMessage error={errors.password} />}\n      </div>\n      <div class=\"field-block\">\n        <input\n          type=\"password\"\n          name=\"confirmpassword\"\n          placeholder=\"Confirm Password\"\n          required=\"\"\n          use:validate={[matchesPassword]}\n        />\n        {errors.confirmpassword && (\n          <ErrorMessage error={errors.confirmpassword} />\n        )}\n      </div>\n\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n};\n\nrender(App, document.getElementById(\"app\"));\n"
    },
    {
      "name": "validation",
      "content": "import { Accessor } from \"solid-js/web\"\nimport { createStore } from \"solid-js/store\";\n\nexport type Validator = (value: HTMLInputElement) => Promise<string | undefined>;\ntype FieldValidators = {\n  element: HTMLInputElement,\n  validators: Validator[]\n}\n\ntype ErrorMap = Record<string, string | undefined>\ntype FieldValidatorMap = Record<string, FieldValidators>\ntype Setter<T> = (value: T) => T | void\n\ndeclare module \"solid-js/web\" {\n  namespace JSX {\n    interface Directives {\n      onInput(set: Setter<String>): void\n      validate: Validator[]\n      formSubmit(ref: HTMLFormElement): void\n    }\n  }\n}\n\nfunction checkValid(\n  { element, validators = [] }: FieldValidators,\n  setErrors: Setter<ErrorMap>,\n  errorClass?: string\n) {\n  return async () => {\n    element.setCustomValidity(\"\");\n    element.checkValidity();\n    let message = element.validationMessage;\n    if (!message) {\n      for (const validator of validators) {\n        const text = await validator(element);\n        if (text) {\n          element.setCustomValidity(text);\n          break;\n        }\n      }\n      message = element.validationMessage;\n    }\n    if (message) {\n      errorClass && element.classList.toggle(errorClass, true);\n      setErrors({ [element.name]: message });\n    }\n  };\n}\n\nexport function useForm({ errorClass }: { errorClass?: string } = {}) {\n  const [errors, setErrors] = createStore<ErrorMap>({})\n  const fields: FieldValidatorMap = {}\n\n  const validate = (ref: HTMLInputElement, accessor: Accessor<Validator[]>) => {\n    const validators = accessor() || [];\n    const config = { element: ref, validators }\n    fields[ref.name] = config\n    ref.onblur = checkValid(config, setErrors, errorClass);\n    ref.oninput = () => {\n      if (!errors[ref.name]) return;\n      setErrors({ [ref.name]: undefined });\n      errorClass && ref.classList.toggle(errorClass, false);\n    };\n  };\n\n  const formSubmit = (ref: HTMLInputElement, accessor: Accessor<Validator[]>) => {\n    const callback = accessor() || (() => {});\n    ref.setAttribute(\"novalidate\", \"\");\n    ref.onsubmit = async (e) => {\n      e.preventDefault();\n      let errored = false;\n\n      for (const k in fields) {\n        const field = fields[k];\n        await checkValid(field, setErrors, errorClass)();\n        if (!errored && field.element.validationMessage) {\n          field.element.focus();\n          errored = true;\n        }\n      }\n      !errored && callback(ref);\n    };\n  };\n\n  return { validate, formSubmit, errors };\n}\n\n/** Helper which doesn't actually do anything, but forces Babel and the IDE to mark the directives as used */\nexport function useDirectives(...directives: ((...args: any[]) => any)[]) {\n  // noinspection BadExpressionStatementJS\n  directives\n}\n"
    },
    {
      "name": "styles",
      "type": "css",
      "content": "input {\n  display: inline-block;\n  padding: 4px;\n  margin-top: 10px;\n  margin-bottom: 10px;\n}\n.error-message {\n  color: red;\n  padding: 8px;\n}\n.error-input {\n  box-shadow: 0px 0px 2px 1px red;\n}"
    }
  ]
}
